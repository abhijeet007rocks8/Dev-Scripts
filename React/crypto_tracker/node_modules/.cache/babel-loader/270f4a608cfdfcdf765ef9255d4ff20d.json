{"ast":null,"code":"// removeSubsets\n// Given an array of nodes, remove any member that is contained by another.\nexports.removeSubsets = function (nodes) {\n  var idx = nodes.length,\n      node,\n      ancestor,\n      replace; // Check if each node (or one of its ancestors) is already contained in the\n  // array.\n\n  while (--idx > -1) {\n    node = ancestor = nodes[idx]; // Temporarily remove the node under consideration\n\n    nodes[idx] = null;\n    replace = true;\n\n    while (ancestor) {\n      if (nodes.indexOf(ancestor) > -1) {\n        replace = false;\n        nodes.splice(idx, 1);\n        break;\n      }\n\n      ancestor = ancestor.parent;\n    } // If the node has been found to be unique, re-insert it.\n\n\n    if (replace) {\n      nodes[idx] = node;\n    }\n  }\n\n  return nodes;\n}; // Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition\n\n\nvar POSITION = {\n  DISCONNECTED: 1,\n  PRECEDING: 2,\n  FOLLOWING: 4,\n  CONTAINS: 8,\n  CONTAINED_BY: 16\n}; // Compare the position of one node against another node in any other document.\n// The return value is a bitmask with the following values:\n//\n// document order:\n// > There is an ordering, document order, defined on all the nodes in the\n// > document corresponding to the order in which the first character of the\n// > XML representation of each node occurs in the XML representation of the\n// > document after expansion of general entities. Thus, the document element\n// > node will be the first node. Element nodes occur before their children.\n// > Thus, document order orders element nodes in order of the occurrence of\n// > their start-tag in the XML (after expansion of entities). The attribute\n// > nodes of an element occur after the element and before its children. The\n// > relative order of attribute nodes is implementation-dependent./\n// Source:\n// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n//\n// @argument {Node} nodaA The first node to use in the comparison\n// @argument {Node} nodeB The second node to use in the comparison\n//\n// @return {Number} A bitmask describing the input nodes' relative position.\n//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n//         a description of these values.\n\nvar comparePos = exports.compareDocumentPosition = function (nodeA, nodeB) {\n  var aParents = [];\n  var bParents = [];\n  var current, sharedParent, siblings, aSibling, bSibling, idx;\n\n  if (nodeA === nodeB) {\n    return 0;\n  }\n\n  current = nodeA;\n\n  while (current) {\n    aParents.unshift(current);\n    current = current.parent;\n  }\n\n  current = nodeB;\n\n  while (current) {\n    bParents.unshift(current);\n    current = current.parent;\n  }\n\n  idx = 0;\n\n  while (aParents[idx] === bParents[idx]) {\n    idx++;\n  }\n\n  if (idx === 0) {\n    return POSITION.DISCONNECTED;\n  }\n\n  sharedParent = aParents[idx - 1];\n  siblings = sharedParent.children;\n  aSibling = aParents[idx];\n  bSibling = bParents[idx];\n\n  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n    if (sharedParent === nodeB) {\n      return POSITION.FOLLOWING | POSITION.CONTAINED_BY;\n    }\n\n    return POSITION.FOLLOWING;\n  } else {\n    if (sharedParent === nodeA) {\n      return POSITION.PRECEDING | POSITION.CONTAINS;\n    }\n\n    return POSITION.PRECEDING;\n  }\n}; // Sort an array of nodes based on their relative position in the document and\n// remove any duplicate nodes. If the array contains nodes that do not belong\n// to the same document, sort order is unspecified.\n//\n// @argument {Array} nodes Array of DOM nodes\n//\n// @returns {Array} collection of unique nodes, sorted in document order\n\n\nexports.uniqueSort = function (nodes) {\n  var idx = nodes.length,\n      node,\n      position;\n  nodes = nodes.slice();\n\n  while (--idx > -1) {\n    node = nodes[idx];\n    position = nodes.indexOf(node);\n\n    if (position > -1 && position < idx) {\n      nodes.splice(idx, 1);\n    }\n  }\n\n  nodes.sort(function (a, b) {\n    var relative = comparePos(a, b);\n\n    if (relative & POSITION.PRECEDING) {\n      return -1;\n    } else if (relative & POSITION.FOLLOWING) {\n      return 1;\n    }\n\n    return 0;\n  });\n  return nodes;\n};","map":{"version":3,"sources":["/home/kriptonian/Desktop/CodeMaster/react/cryptocurrency_tracker/node_modules/react-html-parser/node_modules/domutils/lib/helpers.js"],"names":["exports","removeSubsets","nodes","idx","length","node","ancestor","replace","indexOf","splice","parent","POSITION","DISCONNECTED","PRECEDING","FOLLOWING","CONTAINS","CONTAINED_BY","comparePos","compareDocumentPosition","nodeA","nodeB","aParents","bParents","current","sharedParent","siblings","aSibling","bSibling","unshift","children","uniqueSort","position","slice","sort","a","b","relative"],"mappings":"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","sourcesContent":["// removeSubsets\n// Given an array of nodes, remove any member that is contained by another.\nexports.removeSubsets = function(nodes) {\n\tvar idx = nodes.length, node, ancestor, replace;\n\n\t// Check if each node (or one of its ancestors) is already contained in the\n\t// array.\n\twhile (--idx > -1) {\n\t\tnode = ancestor = nodes[idx];\n\n\t\t// Temporarily remove the node under consideration\n\t\tnodes[idx] = null;\n\t\treplace = true;\n\n\t\twhile (ancestor) {\n\t\t\tif (nodes.indexOf(ancestor) > -1) {\n\t\t\t\treplace = false;\n\t\t\t\tnodes.splice(idx, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tancestor = ancestor.parent;\n\t\t}\n\n\t\t// If the node has been found to be unique, re-insert it.\n\t\tif (replace) {\n\t\t\tnodes[idx] = node;\n\t\t}\n\t}\n\n\treturn nodes;\n};\n\n// Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition\nvar POSITION = {\n\tDISCONNECTED: 1,\n\tPRECEDING: 2,\n\tFOLLOWING: 4,\n\tCONTAINS: 8,\n\tCONTAINED_BY: 16\n};\n\n// Compare the position of one node against another node in any other document.\n// The return value is a bitmask with the following values:\n//\n// document order:\n// > There is an ordering, document order, defined on all the nodes in the\n// > document corresponding to the order in which the first character of the\n// > XML representation of each node occurs in the XML representation of the\n// > document after expansion of general entities. Thus, the document element\n// > node will be the first node. Element nodes occur before their children.\n// > Thus, document order orders element nodes in order of the occurrence of\n// > their start-tag in the XML (after expansion of entities). The attribute\n// > nodes of an element occur after the element and before its children. The\n// > relative order of attribute nodes is implementation-dependent./\n// Source:\n// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n//\n// @argument {Node} nodaA The first node to use in the comparison\n// @argument {Node} nodeB The second node to use in the comparison\n//\n// @return {Number} A bitmask describing the input nodes' relative position.\n//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n//         a description of these values.\nvar comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {\n\tvar aParents = [];\n\tvar bParents = [];\n\tvar current, sharedParent, siblings, aSibling, bSibling, idx;\n\n\tif (nodeA === nodeB) {\n\t\treturn 0;\n\t}\n\n\tcurrent = nodeA;\n\twhile (current) {\n\t\taParents.unshift(current);\n\t\tcurrent = current.parent;\n\t}\n\tcurrent = nodeB;\n\twhile (current) {\n\t\tbParents.unshift(current);\n\t\tcurrent = current.parent;\n\t}\n\n\tidx = 0;\n\twhile (aParents[idx] === bParents[idx]) {\n\t\tidx++;\n\t}\n\n\tif (idx === 0) {\n\t\treturn POSITION.DISCONNECTED;\n\t}\n\n\tsharedParent = aParents[idx - 1];\n\tsiblings = sharedParent.children;\n\taSibling = aParents[idx];\n\tbSibling = bParents[idx];\n\n\tif (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n\t\tif (sharedParent === nodeB) {\n\t\t\treturn POSITION.FOLLOWING | POSITION.CONTAINED_BY;\n\t\t}\n\t\treturn POSITION.FOLLOWING;\n\t} else {\n\t\tif (sharedParent === nodeA) {\n\t\t\treturn POSITION.PRECEDING | POSITION.CONTAINS;\n\t\t}\n\t\treturn POSITION.PRECEDING;\n\t}\n};\n\n// Sort an array of nodes based on their relative position in the document and\n// remove any duplicate nodes. If the array contains nodes that do not belong\n// to the same document, sort order is unspecified.\n//\n// @argument {Array} nodes Array of DOM nodes\n//\n// @returns {Array} collection of unique nodes, sorted in document order\nexports.uniqueSort = function(nodes) {\n\tvar idx = nodes.length, node, position;\n\n\tnodes = nodes.slice();\n\n\twhile (--idx > -1) {\n\t\tnode = nodes[idx];\n\t\tposition = nodes.indexOf(node);\n\t\tif (position > -1 && position < idx) {\n\t\t\tnodes.splice(idx, 1);\n\t\t}\n\t}\n\tnodes.sort(function(a, b) {\n\t\tvar relative = comparePos(a, b);\n\t\tif (relative & POSITION.PRECEDING) {\n\t\t\treturn -1;\n\t\t} else if (relative & POSITION.FOLLOWING) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t});\n\n\treturn nodes;\n};\n"]},"metadata":{},"sourceType":"script"}